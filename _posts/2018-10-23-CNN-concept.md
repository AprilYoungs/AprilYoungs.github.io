---
layout: post
title:  "CNN卷积神经网络"
date:   2018-10-23
categories: concept
---

![](/resource/cnn/CNN_ex.png)
- - -
### 图片分类
做图片分类的时候,我们需要一个神经网络以一张图片为输入,然后输出图片对应的类型.
让我们以一辆车为例子.
![](/resource/cnn/image_classification.png)
这件事对人来说很简单,但是对一个神经网络呢?神经网络会如何处理?

### 图片是像素的集合体
从神经网络的角度图片就是一个数字的矩阵.从下图,你可以看到放大的黑白汽车的一部分.图片由很小的小方格子组成,每个方格称为一个像素.对于黑白图片,每一个像素的值在0~255之间,0代表黑色,255代表白色.
![](/resource/cnn/grayscale_image.png)
正常的彩色图片,图片上的每个像素点都由红、绿、蓝三种像素组成.你可以把这想象成红、绿、蓝三张图片叠加到一起.彩色像素被表示为三个元素的数组.例如,RGB像素值,[255,0,0]是纯红色,而[200,0,200]是紫色.从这个角度,我们可以想象一下每张图片为一个3D的矩阵,有宽、高,还有深度------颜色,黑白图片的深度为1.
![](/resource/cnn/color_image.png)
要创建一个图片分类器,我们需要一个算法,可以观察这些像素并且能够识别出图片中有一辆汽车.我们也希望这个分类器能够在不同光线条件下(晚上或白天)识别汽车,这个分类器能很好的泛化,这样他才能识别出不同环境不同角度下不同的汽车.
![](/resource/cnn/var_cars.png)
观察一下几张汽车的图片,你会发现每张图片的像素都差异很大.所以,这个分类器要做到能够识别出不同场景图片中有汽车存在.

### 数据导向的方法
因为没有明确的方法可以创建一组规则来确定一堆像素是一辆车子,我们将采用数据导向的方法:
> 1. 收集一组有汽车标签的图片
2. 训练一个模型准确预测图片类别

![](/resource/cnn/training_data.png)
在这个例子中,我们计划训练一个卷积神经网络(convolutional neural network).这个网络在训练中,会学到汽车的哪部分为关键特征,例如轮胎和车窗,并且它要足够泛化,这样才能识别不同角度不同环境下的汽车.
* * *

### 卷积神经网络
我们将使用卷积神经网络(CNN)来完成图片分类的任务.CNN能够发现并表示彩色图片空间里的特征.很多神经网络一次只关注一个输入(处理图片的时候,一个像素),但卷积神经网络可以一次接收图片中一个区域的像素,并学会寻找空间上的特征.

每个CNN都是由多个网络层构成,主要的三种网络类型为卷积层(convolutional),池化层(pooling),和全链接层(fully-connected),如下图所示.一般,你可以看到CNN由很多网络层构成,尤其是卷积层和池化层.每个层由多个节点构成,这些节点对输入数据进行相应处理.
![](/resource/cnn/CNN_ex.png)

#### 卷积层
卷积层可以理解为这个神经网络的特征 *提取器*,它被训练来寻找输入图片的空间特征.
这个网络层通过对图片使用一系列不同的图片滤镜,也即卷积核(convolutional kernels)来生成的.这些滤镜在图片上一个像素一个像素的扫描,并且生成一个差不多跟原图片一样大小的输出图片.多个卷积核会生成多个输出图片.
![](/resource/cnn/conv_layer.gif)
如果我们有四个不同的卷积核,这样就会生成四张不同的滤出图片.每个不同的滤镜会提取输入图片中不同的特征,而这些特征对最终的图片分类有帮助.例如,一个滤镜可以检测图片中物体的边缘而另一个可能可以提取色彩中独特的特征.这些滤镜,叠合到一起就是一个卷积网络层.

### 高频率通过滤镜 (High-pass Filter)
高频率通过滤镜用来检测在小范围内强度的剧烈变化.所以,高频率通过滤镜会高亮由暗变亮或由亮变暗的区域.
![](/resource/cnn/filtered_ex.png)
例如,如果我们对一张汽车图片使用高通过滤镜,我们会看到汽车的边缘被检测到,因为边缘明暗变化比较大.物体的边缘通常强度变化比较大,因此,高频率通过滤镜有时候被称为“边缘检测滤镜”.

#### 卷积核
如下图所示,这是一个3x3的卷积核,可以用来检测边缘<br>
<img style="width:auto;" src="/resource/cnn/edge_detection_filter.png">
<br>你可能已经注意到3x3矩阵中数字的总和是0.一个边缘检测滤镜所有元素的总和为0,因为它被用来计算图片临近区域的区别或变化.如果一个区域是均匀的,那么输出为0,也就是没有检测到边缘.如果卷积核的权重总和不是0,那么它计算的输出要么变大要么变小,输出的图片会整体变亮或变暗.

#### 卷积
对一张输入图片 *F(x,y)*,使用滤镜,即使用卷积核 *K* 进行卷积运算.卷积运算符用星号 * 表示.使用卷积核对输入图片进行逐个像素的扫描,进行边缘检测后生成新的图片.
![](/resource/cnn/filter_in_action.gif)

让我们看一个具体的例子.为了方便理解像素级的运算,我将放大汽车图片.
![](/resource/cnn/zoomed_corner.png)
对黑白图片上的每个像素,我们把卷积核放上去,这样被选中的像素在卷积核的中心,并计算卷积.在下图中,我选择中心像素值为200的点为例.
![](/resource/cnn/pixel_selection.png)
计算一个完整的卷积的步骤如下:
1. 把核对应位置的值与像素值相乘.所以3x3卷积核左上角的值(0)和图片上相应位置的像素(150)相乘.
2. 把这些像素点间的乘积进行累加,得到175.这个值就是滤出图片的对应中心点(x,y)的像素值.
![](/resource/cnn/convolution_steps.gif)

对输入图片上的每个像素点进行这种运算,直到我们得到一张完成的输出图片.

#### 权重
在继续之前,我想介绍一个概念.卷积核里边用来乘相应像素值的数值,叫做 *权重*.这是因为他们被用来决定(或衡量)一个像素在生成新的图片时的重要性.你会注意到中间像素的权重是4,这意味着是它比较重要,正向的权重.在3x3的矩阵中,中间像素是决定输出图片像素的最重要的值.
![](/resource/cnn/weights.png)
这个卷积核也包含负值的权重-1.这些值分别在中间点的左右,上下.这些值离中心最近,因为它们对称的分布在中心两边,我们可以推断这个卷积核会检测到任何环绕着中心有剧烈变化的像素.

#### 图片边框
图片边框的像素卷积核无法正常扫描.一个3x3的卷积核无法完美的把中心像素放在图片的边缘或角.事实上,有两种方法可以处理这种状况,一种方式在图片边缘补0,这样卷积核就可以完美的覆盖在图片上;另一种方式是忽略边框的像素,只关注内部那些卷积核可以完美覆盖的像素.
![](/resource/cnn/edge_handling.gif)
通常,边框不会有什么重要的有用信息,但如果你选择忽略这些像素,每张被滤过的图片都会比原来的图片变小一点点.比如说使用一个3x3的卷积核的话,我们实际上会丢失图片上下及左右一个像素的边框.你也可以选择一个比较大的卷积核,3x3是最小的卷积核,比较适合用来检测小范围内的像素.但如果你要分析更大的图片,你可能会想检测更大的像素区域,这样需要使用较大的卷积核,比如5x5,7x7,或者更大.通常,你会使用奇数大小的卷积核,这样卷积核才能完美的覆盖中心像素.
![](/resource/cnn/horizontal_filter.png)
上图是另一种类型的边缘检测滤镜;这个滤镜计算中心像素附近像素的变化,不过它只关注中心像素上边和下边的像素值.这是一个水平边缘检测器.用这种方法,你可以构建一个带方向的边缘检测器!
![](/resource/cnn/CNN_ex.png)
对图片使用这些卷积核可以生成相应的图片,多张滤过的图片就是一个卷积网络.

* * *

### 激活函数
前面提到黑白图片的像素值范围在0~255之间.然而,神经网络的输入在0~1之间效果最好.所以,实际上,CNN的输入是一张像素值在0(黑)和1(白)的黑白图片;比如0.78代表浅灰色.把像素值范围为0~255的图片转化成0~1的操作叫做 *标准化(Normalization)*.每个被卷积计算出来的值会在不同范围内,有的可能是负值.

数据经过卷积网络之后,会有一个 *激活函数* 对数据值进行处理.
![](/resource/cnn/relu_ex.png)
CNN网络通常用ReLu(Rectified Linear Unit)激活函数,这个激活函数会把负值替换成0(黑色).输入为x,如果 x>0,ReLu函数返回 x, 如果 x≤0,返回 0.一个激活函数也会给模型引入非线性,这意味着CNN将会寻找非线性的门槛/边界来有效的分类训练数据集.

- - -

### 最大池化层 (Maxpooling Layer)
卷积网络层之后是一个池化层;最常用的池化层是 *最大池化(maxpooling)* 层.为了描述最大池化层,我将只关注一小块像素区域.首先,最大池化把图片分割成N*N个像素的小矩阵,通常N是2.
<br><img style="width:auto;" src="/resource/cnn/patches.png"><br>
进一步放大得到一个有四个矩阵的图片.一个最大池化层由矩阵的大小 2x2,和步距定义.一个矩阵可以理解成一个2x2的视窗用来选择视窗内最大的元素.然后这个视窗按照一定的步伐大小扫描整张图片.对于一个大小为2x2,步距为2的视窗,它将完美的扫描整张图片.为了让视窗完整的扫描图片,通常池化层的大小和步距一致.
![](/resource/cnn/stride.gif)
对每个2x2的矩阵,最大池化层只选择最大的那个值.在红色的那块区域,它选择140,黄色的那块区域,90,按这种逻辑选择,直到我们从四个矩阵中获得四个数值.
![](/resource/cnn/maxpool.png)
现在,你可能会困惑,为什么要使用最大池化层?使用最大池化层会使图片丢失一些信息.

让我来说明一下.首先,可以降低维度;一张平面图片经过一个CNN网络之后,我们会使它的宽、高变小,深度变大.这个网络萃取图片内容的信息,并且压缩成一个全链接层能够接收的大小.其次,最大池化层让神经网络可以忽略输入图片上微小的变化.想象一下,一个物体上的像素可能会亮一点或暗一点,或者轻微的移动.对于类似的图片,即使有轻微的像素差异,最大池化层提取的最大值也应该是相似的.再者,随着数据在CNN网络层向前推进,通过降低图片数据的宽度和高度,最大池化层可以让后面的网络层获得更大的检测区域.例如,一个3x3卷积核放在原始图片上,它将一次只检测3x3的像素区域,但一样的卷积核,如果放在一个被池化后的原始图片上(例如,一张宽、高缩小一半的图片),它依然会检测一样数量的像素,但这个时候3x3的区域对应的是原始图片上四倍大小的区域.这让CNN后面的卷积层可以检测原始图片上更大区域的特征.

- - -

### 全链接层(Fully-connected Layer)
卷积网络的最后一层是一个全链接层(有时候不只一层).全链接意味这最后一个池化层的每个输出都是全链接层的一个输入节点.例如,对一个最后生成数据是20像素宽和高,深度为10的池化层,全链接层将接收20x20x10=4000的输入数据.神经网络最后的全链接层的作用是生成分类评分,并且根据前面卷积层和池化层提取的特征对数据进行分类;所以全链接层的输出节点数与分类类别数量一致.
![](/resource/cnn/CNN_ex.png)

## 卷积神经网络,总结
CNN由一系列的网络层构成:一系列的卷积层+激活函数+最大池化层,还有全链接层用来生成输入图片的类别评分.CNN中的卷积层是特征提取器;它们提取训练图片的形状和色彩特征.值得一提的是卷积层学会提取图片的特征的行为,是由卷积核的权重决定的.CNN通过向后反馈,在训练中找到了最佳的权重.

reference:
[Convolutional Neural Networks](https://cezannec.github.io/Convolutional_Neural_Networks/)
