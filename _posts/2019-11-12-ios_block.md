---
layout: post
title:  "Block"
date:   2019-11-12
categories: ios
---
**`block`的本质**:OC中的`block`其实是一个封装了函数调用及调用环境的OC对象
![](/resource/block/blocklayout.png)

### block 底层实现数据结构
```cpp
int age = 20;
void (^block)(int, int) = ^(int a, int b){
    NSLog(@"block age -> %d", age);
    NSLog(@"block a -> %d", a);
    NSLog(@"block b -> %d", b);
};
```
定义一个`block`如上面的代码
使用如下指令在`terminal`中执行，把OC代码编译出cpp代码，窥探block cpp 实现的的数据结构
```shell
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m
```
下面截取编译后和上面定义的`block`相关代码
```cpp
// blcok的通用结构
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};
// 描述block的结构体
struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
};
// 当前定义的`block`结构
struct __main_block_impl_0 {
    // block 通用结构
  struct __block_impl impl;
  // block 通用描述
  struct __main_block_desc_0* Desc;
  // block 捕获的变量
  int age;
};

// block 里边封装的函数
static void __main_block_func_0(struct __main_block_impl_0 *__cself, int a, int b) {
  int age = __cself->age; // bound by copy

            NSLog((NSString *)&__NSConstantStringImpl__var_folders_jh_6_2dc41d2nn08vfc324ycsj00000gn_T_main_f1a625_mi_0, age);
            NSLog((NSString *)&__NSConstantStringImpl__var_folders_jh_6_2dc41d2nn08vfc324ycsj00000gn_T_main_f1a625_mi_1, a);
            NSLog((NSString *)&__NSConstantStringImpl__var_folders_jh_6_2dc41d2nn08vfc324ycsj00000gn_T_main_f1a625_mi_2, b);
        }
// 定义block的描述
static struct __main_block_desc_0  __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

// 声明block
 void (*block)(int, int) = ((void (*)(int, int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age));

// 简化之后的版本，去掉类型转换
 void (*block)(int, int) = &__main_block_impl_0(__main_block_func_0,
                                          &__main_block_desc_0_DATA,
                                                                age);
```

把上面定义的`block`转化成结构体
```cpp
 __main_block_impl_0 *cBlock = (__bridge  __main_block_impl_0 *)block;
```
打断点，可以看到`block`转换成结构体之后的里边存储的数据
![](/resource/block/block1.png)
里边的函数指针 `0x100000e80` 指向 `block` 被调用时的函数`0x100000e80`
![](/resource/block/block2.png)
[相关demo代码](https://github.com/AprilYoungs/MJ_course/tree/master/ReviewPrepare/07-block/MyBlock)

### Block 变量捕获
![](/resource/block/block3.png)
#### 普通类型的捕获
分别定义不同类型的变量，在block中调用
```cpp
// 全局变量
int c = 30;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        // 局部变量，默认是 auto，这个的autol可以去掉
        auto int a = 10;
        // 静态变量
        static int b = 20;
        
        void (^block)(void) = ^{
            NSLog(@"block--> %d, %d, %d", a, b, c);
        };

        a *= 2;
        b *= 2;
        c *= 2;

        block();
        //  block--> 10, 40, 60
    }
    return 0;
}
```
可以看出，只有局部变量 a 保留了传进去时的值，static和全局变量都会随着外部更改而更改。
接下来把上面的代码编译成cpp代码，编译后的关键代码如下
```cpp
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

int c = 30;

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int a; //接收a的值
  int *b; // 接收b的地址
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int *_b, int flags=0) : a(_a), b(_b) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int a = __cself->a; // bound by copy
  int *b = __cself->b; // bound by copy

            NSLog((NSString *)&__NSConstantStringImpl__var_folders_jh_6_2dc41d2nn08vfc324ycsj00000gn_T_main_a896b8_mi_0, a, (*b), c);
        }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        auto int a = 10;
        static int b = 20;

        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a, &b));

        a *= 2;
        b *= 2;
        c *= 2;

        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);

    }
    return 0;
}
```
上面代码中
```cpp
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int a; //接收a的值
  int *b; // 接收b的地址
}
```
`block`的结构体存有 `a` 的值，`b` 的地址,使用的时候直接从`block`的结构体中取出
```cpp
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    int a = __cself->a; // bound by copy
    int *b = __cself->b; // bound by copy

    NSLog((NSString *)&__NSConstantStringImpl__var_folders_jh_6_2dc41d2nn08vfc324ycsj00000gn_T_main_a896b8_mi_0, a, (*b), c);
}
```
#### 对象的捕获
```objectivec
@interface AYPerson : NSObject
@property(nonatomic, strong) NSString *name;
@end

@implementation AYPerson
- (void)test{
    void (^block)(void) = ^{
        NSLog(@"block -> %@", self);
    };
    block();
}
@end
```
编译成cpp代码之后的`block`结构体如下
```cpp
struct __AYPerson__test_block_impl_0 {
  struct __block_impl impl;
  struct __AYPerson__test_block_desc_0* Desc;
  AYPerson *self;
};
```
同样的，这个`block`会有指向`AYPerson`实例的指针
```cpp
- (void)test{
    void (^block)(void) = ^{
        NSLog(@"block -> %@", [self name]);
    };
    block();
}
```
在`block`中调用对象的方法
```cpp
struct __AYPerson__test_block_impl_0 {
  struct __block_impl impl;
  struct __AYPerson__test_block_desc_0* Desc;
  AYPerson *self;
};
```
同样会存有指向对象的指针

----

**`Block`捕获的是当前的对象**
如下代码可以证明
```cpp
AYPerson *p = [[AYPerson alloc] init];
void (^block)(void) = ^{
    NSLog(@"main block -> %p", p);
};

block();
NSLog(@"out side block->%p", p);
p = [[AYPerson alloc] init];
block();
NSLog(@"out side block->%p", p);

/**
 MyBlockCapture[44473:892748] main block -> 0x1006ade10
 MyBlockCapture[44473:892748] out side block->0x1006ade10
 MyBlockCapture[44473:892748] main block -> 0x1006ade10
 MyBlockCapture[44473:892748] out side block->0x1006b96e0
 */
 block的结构体
    ｜
    ｜
    ｜
    ｜
    V
 struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  AYPerson *p;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, AYPerson *_p, int flags=0) : p(_p) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```
可以看出`block`会存有传入对象的地址，并持有它

### Block的类型
`block`有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自`NSBlock`类型
`__NSGlobalBlock__` （ `_NSConcreteGlobalBlock` ）
`__NSStackBlock__` （ `_NSConcreteStackBlock` ）
`__NSMallocBlock__` （ `_NSConcreteMallocBlock` ）
![](/resource/block/block4.png)
![](/resource/block/block5.png)
![](/resource/block/block6.png)

在MRC模式下
```cpp
int a = 20;

void (^block1)(void) = ^{
    NSLog(@"test1");
};

void (^block2)(void) = ^{
    NSLog(@"test1 - %d", a);
};

void (^block3)(void) = [^{
    NSLog(@"test1 - %d", a);
} copy];

NSLog(@"block1 -> %@, %@, %@, %@", [block1 class], [[block1 class]superclass], [[[block1 class] superclass] superclass], [[[[block1class] superclass] superclass] superclass]);
NSLog(@"block2 -> %@, %@, %@, %@", [block2 class], [[block3 class]superclass], [[[block2 class] superclass] superclass], [[[[block2class] superclass] superclass] superclass]);
NSLog(@"block3 -> %@, %@, %@, %@", [block3 class], [[block3 class]superclass], [[[block3 class] superclass] superclass], [[[[block3class] superclass] superclass] superclass]);
/**
 block1 -> __NSGlobalBlock__, __NSGlobalBlock, NSBlock, NSObject
 block2 -> __NSStackBlock__, __NSMallocBlock, NSBlock, NSObject
 block3 -> __NSMallocBlock__, __NSMallocBlock, NSBlock, NSObject
 */
```
如上可以看到不同类型的创建及继承类型，所有blcok都继承 `NSBlock`， `NSBlock`继承`NSObject`。
 
 #### `__NSStackBlock__, __NSMallocBlock__` 的比较
在MRC环境中
```cpp
void (^myBlock1)(void);
void (^myBlock2)(void);

void test()
{
    int age = 10;
    myBlock1 = ^{
        NSLog(@"my block1 %d", age);
    };
    
    myBlock2 = [^{
        NSLog(@"my block2 %d", age);
    } copy];
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        test();
        
        myBlock1();
        // my block1 -272632728
        // __NSStackBlock__ 的block 超出定义区间就会被释放
        
        myBlock2();
        // my block2 10
        // __NSMallocBlock__ 的block 存在堆区, 超出定义区间不会被释放
        }
    return 0;
}
```

